#!/usr/bin/env python3

"""
sysmon - a SYStem MONitor written in python, designed to be easy
to understand, and "ready to use", without installing dependecies (except curses)

made by dev64 (also known as .dev, devlocalhost)
"""


import os
import sys
import glob
import time
import curses
import select
import platform
import argparse
import multiprocessing

from datetime import datetime

# savedir, hwmons, swap setup

SHOW_SWAP = None
SAVE_DIR = None
hwmon_dirs_out = glob.glob("/sys/class/hwmon/*")

try:
    os.makedirs("/tmp/sysmon_save", exist_ok=True)
    SAVE_DIR = "/tmp/sysmon_save"

except OSError:
    os.makedirs(".sysmon_save", exist_ok=True)
    SAVE_DIR = ".sysmon_save"

# savedir and hwmons setup

# formatting and arguments


def custom_help_formatter(prog):
    """fixing the ugly looking help menu"""
    return argparse.HelpFormatter(prog, max_help_position=46)


parser_arguments = [
    {
        "short": "-nc",
        "long": "--nocpu",
        "action": "store_true",
        "help": "disables cpuinfo (cpu information, like usage, model, and more)",
        "type": None,
        "nargs": None,
        "default": None,
        "metavar": None,
    },
    {
        "short": "-nm",
        "long": "--nomem",
        "action": "store_true",
        "help": "disables meminfo (memory information, like total, used and more)",
        "type": None,
        "nargs": None,
        "default": None,
        "metavar": None,
    },
    {
        "short": "-nl",
        "long": "--noload",
        "action": "store_true",
        "help": "disables loadavg (load times information, including uptime, and more)",
        "type": None,
        "nargs": None,
        "default": None,
        "metavar": None,
    },
    {
        "short": "-np",
        "long": "--nopid",
        "action": "store_true",
        "help": "disables procpid (shows the most vmrss consuming processes)",
        "type": None,
        "nargs": None,
        "default": None,
        "metavar": None,
    },
    {
        "short": "-nn",
        "long": "--nonet",
        "action": "store_true",
        "help": "disables network_stats (network stats, like received/transfered bytes, and more)",
        "type": None,
        "nargs": None,
        "default": None,
        "metavar": None,
    },
    {
        "short": "-nt",
        "long": "--notemp",
        "action": "store_true",
        "help": "disables cpu temperature",
        "type": None,
        "nargs": None,
        "default": None,
        "metavar": None,
    },
    {
        "short": "-ns",
        "long": "--noswap",
        "action": "store_true",
        "help": "disables swap information in meminfo",
        "type": None,
        "nargs": None,
        "default": None,
        "metavar": None,
    },
    {
        "short": "-p",
        "long": "--procs",
        "action": None,
        "help": "how many processes to show in procpid. Default: 6",
        "type": int,
        "nargs": None,
        "default": 6,
        "metavar": "INT",
    },
    {
        "short": "-s",
        "long": "--sleep",
        "action": None,
        "help": "refresh time. Default: 1.0",
        "type": float,
        "nargs": None,
        "default": 1.0,
        "metavar": "FLOAT",
    },
    {
        "short": "-f",
        "long": "--func",
        "action": None,
        "help": "executes only the mentioned functions",
        "type": str,
        "nargs": "+",
        "default": None,
        "metavar": None,
    },
]

parser = argparse.ArgumentParser(formatter_class=custom_help_formatter)

for argument in parser_arguments:
    print(f"{argument['long']} added")
    
    try:
        parser.add_argument(
            argument["short"],
            argument["long"],
            action=argument["action"],
            help=argument["help"],
            # type=argument["type"],
            # nargs=argument["nargs"],
            default=argument["default"],
            # metavar=argument["metavar"],
        )

    except:
        pass

args = parser.parse_args()

print(args)
print(f"{args.sleep}: {type(args.sleep)}")
print(f"{args.procs}: {type(args.procs)}")

if args.noswap:
    SHOW_SWAP = False

# formatting and arguments

# sysmon basic functions start


def char_padding(char, value):
    """
    return char value times
    """
    return char * value


def convert_bytes(fsize, units=(" bytes", " KiB", " MiB", " GiB", " TiB")):
    """convert bytes to k, m, g and t"""
    for unit in units:
        if fsize < 1024:
            return f"{fsize:.2f}{unit}"
        fsize /= 1024
    return f"{fsize:.2f} {units[-1]}"


def en_open(file, method="r"):
    """modifying the default open method so i dont have to define encoding every time"""
    return open(file, mode=method, encoding="utf-8")


def detect_network_adapter():
    """detect an active network adapter/card/whatever and return its directory"""
    for adapter_dir in glob.glob("/sys/class/net/*"):
        with en_open(adapter_dir + "/type") as device_type:
            if int(device_type.read()) != 772:  # if not loopback device
                with en_open(adapter_dir + "/operstate") as status:
                    if status.read().strip() == "up":
                        return adapter_dir
    return None


def file_has(string, lines):
    """checking if file contains string. return string if contains else return None"""
    for line in lines:
        if line.startswith(string):
            return line.strip().split(":")[1]
    return None


def clean_output(text):
    """
    cleans the output that sysmon reads, so it gets only 1005744
    instead of MemTotal:        1005744 kB
    """
    return text.split(":")[0].strip().replace("kB", "")


def to_bytes(kilobytes):
    """convert kilobytes to bytes"""
    return kilobytes * 1024


def uptime_format():
    """format the uptime from seconds to a human readable format"""
    intervals = (("week", 604800), ("day", 86400), ("hour", 3600), ("minute", 60))
    result = []

    with en_open("/proc/uptime") as uptime_file:
        seconds = int(float(uptime_file.readline().split()[0]))

    original_seconds = seconds

    if seconds < 60:
        return f"{seconds} seconds"

    for time_type, count in intervals:
        value = seconds // count

        if value:
            seconds -= value * count
            result.append(f"{value} {time_type if value == 1 else time_type + 's'}")

    if len(result) > 1:
        result[-1] = "and " + result[-1]

    return (", ".join(result), original_seconds)


def clean_cpu_model(model):
    """cleaning cpu model"""
    replace_stuff = [
        "(R)",
        "(TM)",
        "(tm)",
        "Processor",
        "processor",
        '"AuthenticAMD"',
        "Chip Revision",
        "Technologies, Inc",
        "CPU",
        "with Radeon HD Graphics",
    ]
    for text in replace_stuff:
        model = model.replace(text, "")

    return " ".join(model.split()).split("@", maxsplit=1)[0].rstrip(" ")


# sysmon basic functions end

# sysmon cpu


def cpu_usage():
    """
    /proc/stat - cpu usage of the system
    """

    try:
        if not os.path.exists(SAVE_DIR + "/cpu_old_data"):
            with en_open(SAVE_DIR + "/cpu_old_data", "a") as temp_file:
                temp_file.write("cpu.758102.17.259220.2395399.122421.3.1284")

        with en_open(SAVE_DIR + "/cpu_old_data") as old_stats:
            old_stats = old_stats.readline().split(".")
            previous_data = (
                int(old_stats[1])
                + int(old_stats[2])
                + int(old_stats[3])
                + int(old_stats[6])
                + int(old_stats[7])
            )

        with en_open("/proc/stat") as new_stats:
            new_stats = new_stats.readline().replace("cpu ", "cpu").strip().split(" ")

            current_data = (
                int(new_stats[1])
                + int(new_stats[2])
                + int(new_stats[3])
                + int(new_stats[6])
                + int(new_stats[7])
            )

        total = sum(map(int, old_stats[1:])) - sum(map(int, new_stats[1:]))

        with en_open(SAVE_DIR + "/cpu_old_data", "w") as update_data:
            update_data.write(".".join(new_stats))

        try:
            return round(100 * ((previous_data - current_data) / total))

        except (
            ZeroDivisionError
        ):  # there should be a better way (or maybe thats the only way)
            return 0

    except FileNotFoundError:
        sys.exit("Couldnt find /proc/stat file")

    except PermissionError:
        sys.exit(
            "Couldnt read the file. Do you have read permissions for /proc/stat file?"
        )


def cpu_temp(hwmon_dirs):
    """
    getting the cpu temperature from /sys/class/hwmon
    """

    temperature = "!?"
    allowed_types = ("coretemp", "fam15h_power", "k10temp", "acpitz")

    for temp_dir in hwmon_dirs:
        with en_open(temp_dir + "/name") as temp_type:
            if temp_type.read().strip() in allowed_types:
                try:
                    with en_open(temp_dir + "/temp1_input") as temp_value:
                        temperature = int(temp_value.readline().strip()) // 1000
                        break

                except (FileNotFoundError, OSError):
                    pass

    return temperature


def cpuinfo():
    """
    /proc/cpuinfo - cpu information
    """

    try:
        with en_open("/proc/cpuinfo") as cpuinfo_file:
            cpu_freq = "Unknown"
            model = "Unknown"
            cache_size = "0"
            architecture = platform.machine()

            for line in cpuinfo_file:
                if line.startswith("cpu MHz"):
                    cpu_freq = line.split(":")[1].strip()

                elif line.startswith("model name"):
                    model = clean_cpu_model(line.split(":")[1].strip())
                    model = model if len(model) < 25 else model[:25] + "..."

                elif line.startswith("cache size"):
                    cache_size = line.split(":")[1].strip().replace("KB", "")

                elif line.startswith("Hardware") and architecture in (
                    "aarch64",
                    "armv7l",
                ):
                    model = clean_cpu_model(line.split(":")[1].strip())

            total_cores = os.cpu_count() or "Unknown"
            total_threads = multiprocessing.cpu_count()

            cpu_usage_num = cpu_usage()
            cpu_temperature = str(cpu_temp(hwmon_dirs_out))

            if cpu_temperature != "!?" and not args.notemp:
                cpu_temperature += " Â°C"
                arch_model_temp_line = f"({cpu_temperature}) | {architecture} {model}"

            else:
                arch_model_temp_line = f"| {architecture} {model}"

            cache_memory = convert_bytes(to_bytes(int(cache_size))) + " cache memory"

        return (
            f"  --- /proc/cpuinfo {char_padding('-', 47)}\n"
            f"{char_padding(' ', 11)}Usage: {cpu_usage_num}% "
            + " " * (3 - len(str(cpu_usage_num)))
            + arch_model_temp_line
            + "\n"
            f"   Cores/Threads: {total_cores}/{total_threads} @ {cpu_freq} MHz"
            f" with {cache_memory}\n"
        )

    except FileNotFoundError:
        sys.exit("Couldnt find /proc/cpuinfo file")

    except PermissionError:
        sys.exit(
            "Couldnt read the file. Do you have read permissions for /proc/meminfo file?"
        )


# sysmon cpu

# sysmon meminfo


def meminfo(show_swap):
    """
    /proc/meminfo - system memory information
    """

    try:
        with en_open("/proc/meminfo") as meminfo_file:
            meminfo_data = meminfo_file.readlines()

            memory_total = to_bytes(
                int(clean_output(file_has("MemTotal", meminfo_data)))
            )
            memory_available = to_bytes(
                int(clean_output(file_has("MemAvailable", meminfo_data)))
            )
            memory_cached = (
                to_bytes(int(clean_output(file_has("Cached", meminfo_data))))
                + to_bytes(int(clean_output(file_has("Buffers", meminfo_data))))
                + to_bytes(int(clean_output(file_has("SReclaimable", meminfo_data))))
            )

            memory_free = to_bytes(int(clean_output(file_has("MemFree", meminfo_data))))
            memory_used = round(memory_total - memory_available)
            memory_actual_used = round(
                memory_total
                - to_bytes(int(clean_output(file_has("MemFree", meminfo_data))))
                - to_bytes(int(clean_output(file_has("Buffers", meminfo_data))))
                - to_bytes(int(clean_output(file_has("Cached", meminfo_data))))
                - to_bytes(int(clean_output(file_has("SReclaimable", meminfo_data))))
            )

            memory_used_percent = round((int(memory_used) / int(memory_total)) * 100, 1)
            memory_actual_used_percent = round(
                (int(memory_actual_used) / int(memory_total)) * 100, 1
            )
            memory_available_percent = round(100 - memory_used_percent, 1)
            memory_free_percent = round((int(memory_free) / int(memory_total)) * 100, 1)

            memory_used_format = (
                f"{convert_bytes(memory_used)} ({memory_used_percent}%)"
            )
            memory_avail_format = (
                f"{convert_bytes(memory_available)} " f"({memory_available_percent}%)"
            )

            if (
                to_bytes(int(clean_output(file_has("SwapTotal", meminfo_data)))) != 0
                and SHOW_SWAP is not False
            ):
                show_swap = True

            if show_swap:
                swap_total = to_bytes(
                    int(clean_output(file_has("SwapTotal", meminfo_data)))
                )
                swap_available = to_bytes(
                    int(clean_output(file_has("SwapFree", meminfo_data)))
                )
                swap_cached = to_bytes(
                    int(clean_output(file_has("SwapCached", meminfo_data)))
                )

                swap_used = round(swap_total - swap_available)

                swap_used_percent = round((int(swap_used) / int(swap_total)) * 100, 1)
                swap_available_percent = round(100 - swap_used_percent, 1)

                spaces_swap = (
                    25
                    if str(convert_bytes(swap_total)).split(" ")[1] == "GiB"
                    else 23
                    if str(convert_bytes(swap_total)).split(" ")[1] == "TiB"
                    and str(convert_bytes(memory_total)).split(" ")[1] == "TiB"
                    else 22
                    if str(convert_bytes(swap_total)).split(" ")[1] == "TiB"
                    else 25
                )

                return (
                    f"  --- /proc/meminfo {char_padding('-', 47)}\n"
                    f"     RAM: {char_padding(' ', 25)}Swap:\n"
                    f"         Total: {convert_bytes(memory_total)}"
                    + char_padding(
                        " ", (spaces_swap - 1 - len(convert_bytes(swap_total)))
                    )
                    + f"Total: {convert_bytes(swap_total)}\n"
                    f"          Used: {memory_used_format}"
                    + char_padding(" ", (25 - len(memory_used_format)))
                    + f"Used: {convert_bytes(swap_used)} ({swap_used_percent}%)\n"
                    f"   Actual Used: {convert_bytes(memory_actual_used)} ({memory_actual_used_percent}%)\n"
                    f"     Available: {memory_avail_format}"
                    + char_padding(" ", (20 - len(memory_avail_format)))
                    + f"Available: {convert_bytes(swap_available)} ({swap_available_percent}%)\n"
                    f"          Free: {convert_bytes(memory_free)} ({memory_free_percent}%)\n"
                    f"        Cached: {convert_bytes(memory_cached)}"
                    + char_padding(" ", (23 - len(convert_bytes(memory_cached))))
                    + f"Cached: {convert_bytes(swap_cached)}\n"
                )

            return (
                f"  --- /proc/meminfo {char_padding('-', 47)}\n"
                f"   RAM: {char_padding(' ', 25)}\n"
                f"        Total: {convert_bytes(memory_total)}"
                + char_padding(" ", (24 - len(str(memory_cached))))
                + f"Cached: {convert_bytes(memory_cached)}\n"
                f"         Used: {convert_bytes(memory_used)} ({memory_used_percent}%)"
                + char_padding(" ", (20 - len(str(memory_used_format))))
                + f"Actual Used: {convert_bytes(memory_actual_used)} ({memory_actual_used_percent}%)\n"
                f"    Available: {convert_bytes(memory_available)} ({memory_available_percent}%)"
                + char_padding(" ", (18 - len(str(memory_cached))))
                + f"Free: {convert_bytes(memory_free)} ({memory_free_percent}%)\n"
            )

    except FileNotFoundError:
        sys.exit("Couldnt find /proc/meminfo file")

    except PermissionError:
        sys.exit(
            "Couldnt read the file. Do you have read permissions for /proc/meminfo file?"
        )


# sysmon meminfo

# sysmon loadavg


def loadavg():
    """
    /proc/loadavg - system load times and uptime
    """

    try:
        with en_open("/proc/loadavg") as loadavg_file:
            loadavg_data = loadavg_file.read().split()
            onemin, fivemin, fiveteenmin = loadavg_data[:3]
            entities_active, entities_total = loadavg_data[3].split("/")

            uptime_func_out = uptime_format()

            up_since_fmt = datetime.fromtimestamp(
                time.time() - uptime_func_out[1]
            ).strftime("%A %B %d %Y, %I:%M:%S %p")

        return (
            f"  --- /proc/loadavg {char_padding('-', 47)}\n"
            f"   System load: {onemin}, {fivemin}, {fiveteenmin} (1, 5, 15 mins)\n"
            f"      Entities: {entities_active} executing, {entities_total} total"
            f"\n\n   System up for {uptime_func_out[0]}\n    Since {up_since_fmt}\n"
        )

    except FileNotFoundError:
        sys.exit("Couldn't find /proc/loadavg file")

    except PermissionError:
        sys.exit(
            "Couldn't read the file. Do you have read permissions for /proc/loadavg file?"
        )


# sysmon loadavg

# sysmon procpid


def procpid():
    """
    return the most ram (vmrss) consuming pids, with their state and name
    """

    processes = []

    for entry_dir in os.scandir("/proc"):
        if entry_dir.is_dir() and entry_dir.name.isdigit():
            try:
                with en_open(
                    os.path.join(entry_dir.path, "status"), "r"
                ) as status_file:
                    s_readlines = status_file.readlines()

                    pid_name = None
                    rss = None
                    state = None

                    pid_name_line = next(
                        (line for line in s_readlines if line.startswith("Name:")), None
                    )
                    if pid_name_line:
                        pid_name = pid_name_line.partition(":")[2].strip()

                    rss_line = next(
                        (line for line in s_readlines if line.startswith("VmRSS:")),
                        None,
                    )
                    if rss_line:
                        rss = int(clean_output(rss_line.partition(":")[2].strip()))

                    state_line = next(
                        (line for line in s_readlines if line.startswith("State:")),
                        None,
                    )
                    if state_line:
                        state = state_line.partition("(")[2].partition(")")[0].title()

                    if rss is not None:
                        processes.append(
                            (pid_name, to_bytes(rss), state, entry_dir.name)
                        )

            except FileNotFoundError:
                pass  # processes.append((None, 76328097200209, None, "64"))

    processes.sort(key=lambda a: a[1], reverse=True)

    formatted_data = [
        f"  --- /proc/pid/* {char_padding('-', 49)}\n   Name            PID         RSS            State"
    ]

    for process_name, rss, pstate, pid in processes[: args.procs]:
        rss_usage = convert_bytes(rss) if rss is not None else "!?"

        formatted_data.append(
            f"   {process_name or '!?!?'}{char_padding(' ', (15 - len(process_name or '!?!?')))}"
            f" {pid}{char_padding(' ', (11 - len(pid)))}"
            f" {rss_usage}{char_padding(' ', (14 - len(rss_usage)))} {pstate or '!?!?'}"
        )

    return "\n".join(formatted_data) + "\n"


# sysmon procpid

# sysmon net


def network_stats():
    """
    /sys/class/net/ - network stats, and speed
    """

    adapter_directory = detect_network_adapter()

    if adapter_directory is not None:
        device_name = adapter_directory.split("/")[4]
        if not os.path.isfile(f"{SAVE_DIR}/rx") and not os.path.isfile(f"{SAVE_DIR}tx"):
            with en_open(f"{SAVE_DIR}/rx", "w") as rx_file:
                rx_file.write("0")

            with en_open(f"{SAVE_DIR}/tx", "w") as tx_file:
                tx_file.write("0")

        with en_open(adapter_directory + "/statistics/rx_bytes") as received:
            received = int(received.read().strip())

        with en_open(adapter_directory + "/statistics/tx_bytes") as transferred:
            transferred = int(transferred.read().strip())

        with en_open(f"{SAVE_DIR}/rx") as recv_speed:
            recv_speed = abs(int(recv_speed.read().strip()) - received)

        with en_open(f"{SAVE_DIR}/tx") as transf_speed:
            transf_speed = abs(int(transf_speed.read().strip()) - transferred)

        with en_open(f"{SAVE_DIR}/rx", "w") as rxsave:
            rxsave.write(str(received))

        with en_open(f"{SAVE_DIR}/tx", "w") as txsave:
            txsave.write(str(transferred))

        human_received = convert_bytes(received)
        human_transferred = convert_bytes(transferred)

        return (
            f"  --- /sys/class/net/{device_name} {char_padding('-', (45 - len(device_name)))}\n"
            f"      Received: {human_received}"
            + char_padding(" ", (14 - len(human_received)))
            + f"({received} bytes)\n"
            f"   Transferred: {human_transferred}"
            + char_padding(" ", (14 - len(human_transferred)))
            + f"({transferred} bytes)\n"
            f"         Speed: Down {convert_bytes(recv_speed)}"
            + char_padding(" ", (14 - len(convert_bytes(recv_speed))))
            + f"| Up {convert_bytes(transf_speed)}\n"
        )

    return f"  --- /sys/class/net/!?!? {char_padding('-', 41)}\n"


# sysmon net

# sysmon printing part

func_dict = {
    "cpu": cpuinfo,
    "mem": lambda: meminfo(SHOW_SWAP),
    "load": loadavg,
    "pid": procpid,
    "net": network_stats,
}

if args.func:
    for name, func in func_dict.items():
        if name not in args.func:
            setattr(args, "no" + name, True)


def main(stdscr):
    """main printing method, what you see when you run sysmon"""

    stdscr.nodelay(True)

    curses.curs_set(0)
    curses.use_default_colors()

    try:
        while True:
            stdscr.erase()

            stdscr.addstr(
                f" --- Sysmon | {datetime.now().strftime('%I:%M:%S %p')} "
                + "-" * 42
                + "\n"
            )

            for func_name, function in func_dict.items():
                if not getattr(args, "no" + func_name, False):
                    stdscr.addstr(function())

            stdscr.addstr(f" {'-' * 67}")
            stdscr.refresh()

            rlist = select.select([sys.stdin], [], [], args.sleep)

            if rlist:
                kinput = stdscr.getch()

                if kinput == ord("q"):
                    curses.curs_set(1)
                    break

    except curses.error:
        sys.exit("Not enough space. Please resize")

    except KeyboardInterrupt:
        curses.endwin()
        curses.curs_set(1)

    curses.endwin()


curses.wrapper(main)

# sysmon printing part
